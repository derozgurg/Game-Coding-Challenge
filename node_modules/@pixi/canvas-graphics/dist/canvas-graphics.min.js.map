{"version":3,"file":"canvas-graphics.min.js","sources":["../src/Graphics.js","../src/CanvasGraphicsRenderer.js"],"sourcesContent":["import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode, resolution = 1)\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n    const texture = Texture.from(canvasBuffer.baseTexture._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.resolution = resolution;\n    texture.baseTexture.update();\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n","import { SHAPES, Matrix } from '@pixi/math';\nimport { canvasUtils } from '@pixi/canvas-renderer';\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The current PIXI renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n        this._svgMatrix = null;\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     *\n     * @private\n     * @param {PIXI.FillStyle} style\n     * @param {number} tint\n     * @returns {string|CanvasPattern}\n     */\n    _calcCanvasStyle(style, tint)\n    {\n        let res;\n\n        if (style.texture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).substr(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param {PIXI.Graphics} graphics - the actual graphics object to render\n     */\n    render(graphics)\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.setContextTransform(transform);\n\n        // update tint if graphics was dirty\n        if (graphics.canvasTintDirty !== graphics.geometry.dirty\n            || graphics._prevTint !== graphics.tint)\n        {\n            this.updateGraphicsTint(graphics);\n        }\n\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            if (fillStyle.visible)\n            {\n                contextFillStyle = this._calcCanvasStyle(fillStyle, data._fillTint);\n            }\n            if (lineStyle.visible)\n            {\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, data._lineTint);\n            }\n\n            context.lineWidth = lineStyle.width;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (shape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].shape.points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if (holes[k].shape.closeStroke)\n                        {\n                            context.closePath();\n                        }\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(shape.x, shape.y, shape.width, shape.height);\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(shape.x, shape.y, shape.width, shape.height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                context.beginPath();\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w; // x-end\n                const ye = y + h; // y-end\n                const xm = x + (w / 2); // x-middle\n                const ym = y + (h / 2); // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.beginPath();\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n                if (lineStyle.visible)\n                {\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the tint of a graphics object\n     *\n     * @protected\n     * @param {PIXI.Graphics} graphics - the graphics that will have its tint updated\n     */\n    updateGraphicsTint(graphics)\n    {\n        graphics._prevTint = graphics.tint;\n        graphics.canvasTintDirty = graphics.geometry.dirty;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n        const graphicsData = graphics.geometry.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            // super inline, cos optimization :)\n            data._fillTint = (\n                (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((fillColor & 0xFF) / 255) * tintB * 255)\n            );\n\n            data._lineTint = (\n                (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                + (((lineColor & 0xFF) / 255) * tintB * 255)\n            );\n        }\n    }\n\n    setPatternTransform(pattern, matrix)\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg && svg.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        this._svgMatrix.a = matrix.a;\n        this._svgMatrix.b = matrix.b;\n        this._svgMatrix.c = matrix.c;\n        this._svgMatrix.d = matrix.d;\n        this._svgMatrix.e = matrix.tx;\n        this._svgMatrix.f = matrix.ty;\n        pattern.setTransform(this._svgMatrix.inverse());\n    }\n    /**\n     * destroy graphics object\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n"],"names":["canvasRenderer","CanvasGraphicsRenderer","renderer","this","_svgMatrix","_calcCanvasStyle","style","tint","res","texture","valid","canvasUtils","getTintedPattern","setPatternTransform","matrix","Matrix","IDENTITY","toString","substr","render","graphics","const","context","worldAlpha","transform","worldTransform","setContextTransform","canvasTintDirty","geometry","dirty","_prevTint","updateGraphicsTint","setBlendMode","blendMode","contextFillStyle","contextStrokeStyle","graphicsData","i","length","data","shape","fillStyle","lineStyle","visible","_fillTint","_lineTint","lineWidth","width","type","SHAPES","POLY","beginPath","let","points","holes","outerArea","innerArea","px","py","moveTo","j","lineTo","closeStroke","closePath","k","globalAlpha","alpha","fill","strokeStyle","stroke","RECT","fillRect","x","y","height","strokeRect","CIRC","arc","radius","Math","PI","ELIP","w","h","ox","oy","xe","ye","xm","ym","bezierCurveTo","RREC","rx","ry","maxRadius","min","quadraticCurveTo","tintR","tintG","tintB","fillColor","color","lineColor","pattern","svg","document","createElementNS","createSVGMatrix","setTransform","a","b","c","d","e","tx","f","ty","inverse","destroy","tempMatrix","prototype","generateCanvasTexture","scaleMode","resolution","bounds","getLocalBounds","canvasBuffer","RenderTexture","create","CanvasRenderer","updateLocalTransform","localTransform","copyTo","invert","Texture","from","baseTexture","_canvasRenderTarget","canvas","update","cachedGraphicsData","_renderCanvas","isMask","finishPoly","plugins"],"mappings":"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"}